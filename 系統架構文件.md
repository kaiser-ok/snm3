# GSNM 網路管理系統 - 系統架構文件

**文件版本:** 1.0
**最後更新:** 2025-11-10
**系統名稱:** GSNM (GSN Network Management System)
**目標讀者:** R&D 團隊、Support Team、系統管理員

---

## 目錄

1. [系統概述](#系統概述)
2. [系統架構總覽](#系統架構總覽)
3. [核心組件說明](#核心組件說明)
4. [PHP 應用程式架構](#php-應用程式架構)
5. [Redis 快取架構](#redis-快取架構)
6. [數據存儲架構](#數據存儲架構)
7. [數據流向與處理](#數據流向與處理)
8. [部署架構](#部署架構)
9. [API 設計](#api-設計)
10. [監控與告警](#監控與告警)
11. [安全架構](#安全架構)
12. [效能優化](#效能優化)
13. [故障排查指南](#故障排查指南)

---

## 系統概述

### 1.1 系統定位

GSNM 是一個企業級網路管理與監控系統，提供全面的網路可視化、流量分析、設備管理和安全監控能力。

### 1.2 核心功能

#### 網路監控與管理
- **設備管理:** 交換機、路由器、防火牆等網路設備的集中管理
- **拓撲發現:** 自動發現網路拓撲結構和設備連接關係
- **性能監控:** 實時監控設備 CPU、Memory、Port 流量等硬體狀態
- **SNMP 管理:** 支援 SNMPv1/v2c/v3 協議的設備監控

#### 流量分析
- **NetFlow/IPFIX 收集:** 透過 Radar 探測器收集網路流量數據
- **深度流量檢測 (DPI):** 支援 L7 應用層協議識別
- **流量統計:** 多時間粒度統計（5分鐘、1小時、1天）
- **異常檢測:** 基於基線的異常流量偵測

#### 安全管理
- **威脅情報比對:** 整合第三方威脅情報源
- **IP/MAC 黑名單:** 動態黑名單管理與自動封鎖
- **防火牆整合:** 與防火牆聯動實現自動化安全響應
- **安全事件追蹤:** 完整的安全事件記錄與審計

#### 用戶管理
- **Radius AAA:** 用戶認證、授權與計費
- **設備綁定:** 用戶設備管理與 MAC 綁定
- **訪客管理:** 訪客網路接入管理
- **配額管理:** 流量配額與設備數量限制

### 1.3 系統特色

- ✅ **混合數據庫架構:** ElasticSearch + MySQL + Redis
- ✅ **多租戶支援:** 通過 Unit ID 實現多單位隔離
- ✅ **分散式收集:** Radar 探測器分散部署，中心化管理
- ✅ **實時處理:** 流量數據實時收集與分析
- ✅ **高效能快取:** Redis 快取熱點數據，提升響應速度
- ✅ **可擴展性:** 支援水平擴展與高可用部署

---

## 系統架構總覽

### 2.1 架構圖

```
┌─────────────────────────────────────────────────────────────────────┐
│                           網路設備層                                  │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │ 交換機    │  │ 路由器    │  │ 防火牆    │  │ 終端設備  │           │
│  └─────┬────┘  └─────┬────┘  └─────┬────┘  └─────┬────┘           │
│        │ SNMP        │ NetFlow     │ Syslog      │                 │
└────────┼─────────────┼─────────────┼─────────────┼─────────────────┘
         │             │             │             │
         └─────────────┴──────┬──────┴─────────────┘
                              │
                              ▼
                    ┌───────────────────┐
                    │  Radar 探測器      │
                    │  (外部專案)        │
                    │                   │
                    │  收集並上傳數據    │
                    └─────────┬─────────┘
                              │
         ┌────────────────────┼────────────────────┐
         │                    │                    │
         ▼                    ▼                    ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│ ElasticSearch   │  │ MySQL/MariaDB   │  │ Redis Cache     │
│ (時序數據)       │  │ (關係數據)       │  │ (快取層)        │
│                 │  │                 │  │                 │
│ • Flow 流量     │  │ • 設備配置       │  │ • 查詢結果      │
│ • IP/MAC 映射   │  │ • 用戶帳號       │  │ • Session       │
│ • 設備狀態      │  │ • 威脅情報       │  │ • 統計數據      │
│ • 統計數據      │  │ • 系統配置       │  │ • API 限流      │
└────────┬────────┘  └────────┬────────┘  └────────┬────────┘
         │                    │                    │
         └────────────────────┼────────────────────┘
                              │
                              ▼
         ┌────────────────────────────────────────┐
         │        PHP 應用程式層                   │
         │  ┌──────────────────────────────────┐  │
         │  │  Web 框架 (MVC)                  │  │
         │  │  • Controllers (業務邏輯)        │  │
         │  │  • Models (數據模型)             │  │
         │  │  • Views (頁面模板)              │  │
         │  └──────────────────────────────────┘  │
         │  ┌──────────────────────────────────┐  │
         │  │  核心服務                         │  │
         │  │  • 設備管理服務                   │  │
         │  │  • 流量分析服務                   │  │
         │  │  • 安全監控服務                   │  │
         │  │  • 用戶認證服務                   │  │
         │  │  • 告警引擎                       │  │
         │  └──────────────────────────────────┘  │
         │  ┌──────────────────────────────────┐  │
         │  │  背景任務 (Cron Jobs)            │  │
         │  │  • 數據彙總                       │  │
         │  │  • 威脅情報更新                   │  │
         │  │  • 報表生成                       │  │
         │  │  • 快取預熱                       │  │
         │  └──────────────────────────────────┘  │
         └────────────────┬───────────────────────┘
                          │
                          ▼
         ┌────────────────────────────────────────┐
         │            前端展示層                   │
         │  ┌──────┐  ┌──────┐  ┌──────┐         │
         │  │儀表板│  │流量  │  │設備  │  ┌────┐ │
         │  │      │  │分析  │  │管理  │  │安全│ │
         │  └──────┘  └──────┘  └──────┘  └────┘ │
         └────────────────────────────────────────┘
```

### 2.2 系統分層

| 層級 | 職責 | 主要技術 |
|------|------|----------|
| **網路設備層** | 提供網路數據源 | 交換機、路由器、防火牆 |
| **數據收集層** | 分散式數據收集 | Radar (外部專案) |
| **數據存儲層** | 持久化與快取 | ElasticSearch + MySQL + Redis |
| **應用服務層** | 業務邏輯處理 | PHP (MVC 框架) |
| **展示層** | 用戶介面 | HTML/CSS/JavaScript |

---

## 核心組件說明

### 3.1 數據收集層 - Radar 探測器

#### 角色定位
Radar 是部署在各單位現場的**外部數據收集專案**，負責收集網路設備數據並上傳至中心系統。

#### 提供的數據類型

**1. NetFlow/IPFIX 流量數據**
```
輸出至 ElasticSearch:
→ radar_flow_collector-YYYY.MM.DD

包含資訊:
• 來源/目的 IP、Port
• 協議類型 (TCP/UDP/ICMP)
• 流量統計 (Bytes/Packets)
• L7 應用層協議 (HTTP/DNS/DHCP等)
• 網路延遲指標
• NAT 轉換記錄
```

**2. SNMP 採集數據**
```
輸出至 ElasticSearch:
→ status-YYYY.MM.DD (設備狀態)
→ ip_mapping-YYYY.MM.DD (IP/MAC 映射)
→ location-YYYY.MM.DD (設備位置)
→ statistics_switch_5m/1h/1d (流量統計)

包含資訊:
• 設備硬體狀態 (CPU/Memory)
• Port 流量統計
• ARP 表 (IP→MAC 映射)
• FDB 表 (MAC→Port 位置)
```

**3. Syslog 日誌**
```
輸出至 ElasticSearch:
→ syslog-YYYY.MM.DD

包含資訊:
• 系統事件日誌
• 認證失敗記錄
• Port Up/Down 事件
```

#### 部署模式

```
中心系統
    │
    │ (VPN/專線連線)
    │
    ├─ Radar 1 (單位 A) → 管理網段 192.168.x.x
    ├─ Radar 2 (單位 B) → 管理網段 10.x.x.x
    └─ Radar N (單位 N) → 管理網段 172.16.x.x
```

**配置管理:**
- Radar 在 MySQL `radar` 表中註冊
- 通過 `radar_mac` 唯一識別
- 任務通過 `radar_task` 表統一管理

> **注意:** Radar 內部實作細節屬於獨立專案，本文件不涵蓋其內部架構。

### 3.2 數據存儲層

#### ElasticSearch - 時序數據庫

**角色:** 存儲所有時序數據、日誌和大量查詢數據

**主要索引:**

| 索引類型 | 索引名稱 | 數據量 | 保留期 |
|---------|---------|--------|--------|
| **流量記錄** | radar_flow_collector-* | 34-57M/日 (5-15GB) | 30-90天 |
| **IP/MAC映射** | ip_mapping-* | 500-1400/日 | 180天 |
| **設備狀態** | status-* | 6K-25K/日 | 90天 |
| **流量統計** | statistics_switch_5m/1h/1d-* | 依粒度 | 7/30/365天 |
| **Syslog** | syslog-* | 4-6M/日 (1-1.3GB) | 30天 |

**索引策略:**
- 按日期/月份分區
- 自動生命週期管理 (ILM)
- 冷熱數據分層

#### MariaDB/MySQL - 關係數據庫

**角色:** 存儲配置、關係數據、用戶資訊

**核心表分類:**

```
設備管理:
├─ Device (設備主表)
├─ Unit (單位/組織)
├─ Vendor (設備廠商)
└─ device_topology_attrs (拓撲屬性)

用戶管理:
├─ User_Account (終端用戶)
├─ User_Station (終端設備)
├─ LoginUser (管理員)
└─ UserGroup (權限群組)

安全管理:
├─ threat_intelligence (威脅情報)
├─ Security_log (安全事件)
├─ BlackList (黑名單)
└─ firewall_security_block_ip_records (防火牆日誌)

網路管理:
├─ online_data (在線統計)
├─ ip_alias (IP別名)
├─ BaseLine (流量基線)
└─ Vlan (VLAN配置)

系統配置:
├─ General_setting (系統設定)
├─ API_Key (API金鑰)
├─ radar (Radar配置)
└─ community (SNMP配置)
```

#### Redis - 快取層

**角色:** 高速快取熱點數據，提升系統響應速度

詳細說明請見 [第5章 Redis 快取架構](#redis-快取架構)

---

## PHP 應用程式架構

### 4.1 整體架構

#### MVC 架構模式

```
┌─────────────────────────────────────────────────────────────┐
│                         前端請求                             │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
                    ┌─────────────┐
                    │   Router    │
                    │  (路由分發)  │
                    └──────┬──────┘
                           │
                           ▼
┌──────────────────────────────────────────────────────────────┐
│                      Controllers 層                           │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐        │
│  │ DeviceCtrl   │ │ TrafficCtrl  │ │ SecurityCtrl │   ...  │
│  │              │ │              │ │              │        │
│  │ • list()     │ │ • topN()     │ │ • events()   │        │
│  │ • detail()   │ │ • analyze()  │ │ • block()    │        │
│  │ • add()      │ │ • protocols()│ │ • unblock()  │        │
│  │ • update()   │ │              │ │              │        │
│  └──────┬───────┘ └──────┬───────┘ └──────┬───────┘        │
└─────────┼────────────────┼────────────────┼─────────────────┘
          │                │                │
          └────────────────┼────────────────┘
                           │
                           ▼
┌──────────────────────────────────────────────────────────────┐
│                       Services 層                             │
│  ┌─────────────────┐ ┌─────────────────┐ ┌───────────────┐ │
│  │ DeviceService   │ │ TrafficService  │ │SecurityService│ │
│  │                 │ │                 │ │               │ │
│  │ 業務邏輯處理     │ │ 流量分析邏輯     │ │ 安全檢測邏輯  │ │
│  │ 數據驗證        │ │ 統計計算        │ │ 威脅比對      │ │
│  │ 快取處理        │ │ 快取策略        │ │ 自動封鎖      │ │
│  └────────┬────────┘ └────────┬────────┘ └───────┬───────┘ │
└───────────┼─────────────────────┼──────────────────┼─────────┘
            │                     │                  │
            └─────────────────────┼──────────────────┘
                                  │
                                  ▼
┌──────────────────────────────────────────────────────────────┐
│                        Models 層                              │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐        │
│  │ DeviceModel  │ │ ElasticModel │ │ RedisModel   │        │
│  │              │ │              │ │              │        │
│  │ MySQL CRUD   │ │ ES 查詢封裝  │ │ 快取操作     │        │
│  └──────┬───────┘ └──────┬───────┘ └──────┬───────┘        │
└─────────┼────────────────┼────────────────┼─────────────────┘
          │                │                │
          ▼                ▼                ▼
    ┌─────────┐      ┌──────────┐    ┌─────────┐
    │  MySQL  │      │ElasticSrch│    │  Redis  │
    └─────────┘      └──────────┘    └─────────┘
```

### 4.2 目錄結構

```
/var/www/html/snm-admin-web/
│
├── app/
│   ├── Controllers/          # 控制器
│   │   ├── DeviceController.php
│   │   ├── TrafficController.php
│   │   ├── SecurityController.php
│   │   ├── UserController.php
│   │   ├── RadiusController.php
│   │   └── DashboardController.php
│   │
│   ├── Models/              # 數據模型
│   │   ├── Database/
│   │   │   ├── DeviceModel.php
│   │   │   ├── UserModel.php
│   │   │   ├── SecurityModel.php
│   │   │   └── BaseModel.php
│   │   ├── Elasticsearch/
│   │   │   ├── FlowModel.php
│   │   │   ├── StatusModel.php
│   │   │   └── ElasticBaseModel.php
│   │   └── Cache/
│   │       └── RedisModel.php
│   │
│   ├── Services/            # 業務邏輯服務
│   │   ├── DeviceService.php
│   │   ├── TrafficService.php
│   │   ├── SecurityService.php
│   │   ├── ThreatIntelService.php
│   │   ├── AlertService.php
│   │   └── ReportService.php
│   │
│   ├── Libraries/           # 核心函式庫
│   │   ├── Database.php     # MySQL 連線類
│   │   ├── Elasticsearch.php # ES 客戶端封裝
│   │   ├── RedisClient.php  # Redis 客戶端
│   │   ├── Auth.php         # 認證類
│   │   └── Utils.php        # 工具函數
│   │
│   ├── Middleware/          # 中介軟體
│   │   ├── AuthMiddleware.php
│   │   ├── RateLimitMiddleware.php
│   │   └── UnitFilterMiddleware.php
│   │
│   └── Config/              # 配置文件
│       ├── database.php
│       ├── elasticsearch.php
│       ├── redis.php
│       ├── app.php
│       └── routes.php
│
├── public/                  # 公開目錄 (Web根目錄)
│   ├── index.php           # 入口文件
│   ├── assets/
│   │   ├── css/
│   │   ├── js/
│   │   └── images/
│   └── api/                # API 端點
│       └── v1/
│
├── views/                   # 視圖模板
│   ├── layouts/
│   │   ├── header.php
│   │   ├── footer.php
│   │   └── sidebar.php
│   ├── dashboard/
│   │   └── index.php
│   ├── devices/
│   │   ├── list.php
│   │   └── detail.php
│   ├── traffic/
│   └── security/
│
├── cron/                    # 定時任務腳本
│   ├── update_threat_intel.php
│   ├── generate_statistics.php
│   ├── check_device_health.php
│   ├── cache_warmup.php
│   └── cleanup_old_data.php
│
├── logs/                    # 應用日誌
│   ├── application.log
│   ├── error.log
│   └── access.log
│
└── vendor/                  # Composer 依賴
    └── autoload.php
```

### 4.3 核心類別說明

#### 4.3.1 數據庫連線類

**Database.php** - MySQL 連線池管理

```php
<?php
namespace App\Libraries;

class Database {
    private static $instance = null;
    private $connection;
    private $config;

    private function __construct() {
        $this->config = require __DIR__ . '/../Config/database.php';
        $this->connect();
    }

    private function connect() {
        try {
            $dsn = sprintf(
                "mysql:host=%s;port=%d;dbname=%s;charset=utf8mb4",
                $this->config['host'],
                $this->config['port'],
                $this->config['database']
            );

            $this->connection = new \PDO($dsn,
                $this->config['username'],
                $this->config['password'],
                [
                    \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
                    \PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC,
                    \PDO::ATTR_EMULATE_PREPARES => false,
                    \PDO::ATTR_PERSISTENT => true, // 持久連線
                ]
            );
        } catch (\PDOException $e) {
            error_log("Database connection failed: " . $e->getMessage());
            throw $e;
        }
    }

    public static function getInstance() {
        if (self::$instance === null) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    public function query($sql, $params = []) {
        $stmt = $this->connection->prepare($sql);
        $stmt->execute($params);
        return $stmt;
    }

    public function fetchAll($sql, $params = []) {
        return $this->query($sql, $params)->fetchAll();
    }

    public function fetchOne($sql, $params = []) {
        return $this->query($sql, $params)->fetch();
    }

    public function insert($table, $data) {
        $keys = array_keys($data);
        $fields = implode(', ', $keys);
        $placeholders = ':' . implode(', :', $keys);

        $sql = "INSERT INTO {$table} ({$fields}) VALUES ({$placeholders})";
        $this->query($sql, $data);

        return $this->connection->lastInsertId();
    }

    public function update($table, $data, $where, $whereParams = []) {
        $set = [];
        foreach (array_keys($data) as $key) {
            $set[] = "{$key} = :{$key}";
        }
        $setClause = implode(', ', $set);

        $sql = "UPDATE {$table} SET {$setClause} WHERE {$where}";
        $params = array_merge($data, $whereParams);

        return $this->query($sql, $params)->rowCount();
    }

    public function delete($table, $where, $params = []) {
        $sql = "DELETE FROM {$table} WHERE {$where}";
        return $this->query($sql, $params)->rowCount();
    }

    public function beginTransaction() {
        return $this->connection->beginTransaction();
    }

    public function commit() {
        return $this->connection->commit();
    }

    public function rollback() {
        return $this->connection->rollBack();
    }
}
```

#### 4.3.2 ElasticSearch 客戶端

**Elasticsearch.php**

```php
<?php
namespace App\Libraries;

use Elasticsearch\ClientBuilder;

class Elasticsearch {
    private static $instance = null;
    private $client;
    private $config;

    private function __construct() {
        $this->config = require __DIR__ . '/../Config/elasticsearch.php';

        $this->client = ClientBuilder::create()
            ->setHosts([$this->config['host']])
            ->build();
    }

    public static function getInstance() {
        if (self::$instance === null) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    /**
     * 搜尋文檔
     */
    public function search($index, $body) {
        try {
            $params = [
                'index' => $index,
                'body' => $body
            ];

            return $this->client->search($params);
        } catch (\Exception $e) {
            error_log("ES search error: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * 查詢流量數據
     */
    public function searchFlows($unitId, $timeRange, $filters = []) {
        $must = [
            ['term' => ['unit_id' => $unitId]],
            ['range' => [
                'FLOW_START_MILLISECONDS' => [
                    'gte' => $timeRange['start'],
                    'lte' => $timeRange['end']
                ]
            ]]
        ];

        // 合併額外過濾條件
        if (!empty($filters)) {
            $must = array_merge($must, $filters);
        }

        $body = [
            'query' => [
                'bool' => [
                    'must' => $must
                ]
            ],
            'size' => $this->config['max_result_window'] ?? 10000,
            'sort' => [
                'FLOW_START_MILLISECONDS' => ['order' => 'desc']
            ]
        ];

        return $this->search('radar_flow_collector-*', $body);
    }

    /**
     * 聚合查詢 - Top N
     */
    public function aggregateTopN($index, $field, $size = 10, $filters = []) {
        $body = [
            'size' => 0,
            'query' => [
                'bool' => [
                    'must' => $filters
                ]
            ],
            'aggs' => [
                'top_items' => [
                    'terms' => [
                        'field' => $field,
                        'size' => $size,
                        'order' => ['total_bytes' => 'desc']
                    ],
                    'aggs' => [
                        'total_bytes' => [
                            'sum' => ['field' => 'TOTAL_BYTES']
                        ],
                        'total_packets' => [
                            'sum' => ['field' => 'TOTAL_PKTS']
                        ]
                    ]
                ]
            ]
        ];

        return $this->search($index, $body);
    }

    /**
     * 獲取設備狀態
     */
    public function getDeviceStatus($unitId, $targetIp, $date = null) {
        if ($date === null) {
            $date = date('Y.m.d');
        }

        $body = [
            'query' => [
                'bool' => [
                    'must' => [
                        ['term' => ['unit_id' => $unitId]],
                        ['term' => ['target' => $targetIp]]
                    ]
                ]
            ],
            'size' => 1,
            'sort' => [
                'timestamp' => ['order' => 'desc']
            ]
        ];

        return $this->search("status-{$date}", $body);
    }

    /**
     * 批次寫入
     */
    public function bulk($body) {
        $params = ['body' => $body];
        return $this->client->bulk($params);
    }
}
```

#### 4.3.3 Redis 客戶端

**RedisClient.php**

```php
<?php
namespace App\Libraries;

class RedisClient {
    private static $instance = null;
    private $redis;
    private $config;

    private function __construct() {
        $this->config = require __DIR__ . '/../Config/redis.php';
        $this->connect();
    }

    private function connect() {
        $this->redis = new \Redis();

        $connected = $this->redis->connect(
            $this->config['host'],
            $this->config['port'],
            $this->config['timeout'] ?? 2.5
        );

        if (!$connected) {
            throw new \Exception("Cannot connect to Redis");
        }

        // 認證 (如果有設定密碼)
        if (!empty($this->config['password'])) {
            $this->redis->auth($this->config['password']);
        }

        // 選擇資料庫
        $this->redis->select($this->config['database'] ?? 0);

        // 設定序列化方式
        $this->redis->setOption(\Redis::OPT_SERIALIZER, \Redis::SERIALIZER_PHP);
    }

    public static function getInstance() {
        if (self::$instance === null) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    public function get($key) {
        return $this->redis->get($key);
    }

    public function set($key, $value, $ttl = null) {
        if ($ttl !== null) {
            return $this->redis->setex($key, $ttl, $value);
        }
        return $this->redis->set($key, $value);
    }

    public function delete($key) {
        return $this->redis->del($key);
    }

    public function exists($key) {
        return $this->redis->exists($key);
    }

    public function expire($key, $ttl) {
        return $this->redis->expire($key, $ttl);
    }

    // Hash 操作
    public function hGet($key, $field) {
        return $this->redis->hGet($key, $field);
    }

    public function hSet($key, $field, $value) {
        return $this->redis->hSet($key, $field, $value);
    }

    public function hGetAll($key) {
        return $this->redis->hGetAll($key);
    }

    // List 操作
    public function lPush($key, $value) {
        return $this->redis->lPush($key, $value);
    }

    public function rPush($key, $value) {
        return $this->redis->rPush($key, $value);
    }

    public function lRange($key, $start, $end) {
        return $this->redis->lRange($key, $start, $end);
    }

    // Set 操作
    public function sAdd($key, $member) {
        return $this->redis->sAdd($key, $member);
    }

    public function sMembers($key) {
        return $this->redis->sMembers($key);
    }

    public function sIsMember($key, $member) {
        return $this->redis->sIsMember($key, $member);
    }

    // Sorted Set 操作
    public function zAdd($key, $score, $member) {
        return $this->redis->zAdd($key, $score, $member);
    }

    public function zRange($key, $start, $end, $withScores = false) {
        return $this->redis->zRange($key, $start, $end, $withScores);
    }

    public function zRevRange($key, $start, $end, $withScores = false) {
        return $this->redis->zRevRange($key, $start, $end, $withScores);
    }

    // 快取輔助方法
    public function remember($key, $ttl, $callback) {
        $value = $this->get($key);

        if ($value === false) {
            $value = $callback();
            $this->set($key, $value, $ttl);
        }

        return $value;
    }

    public function __call($method, $args) {
        return call_user_func_array([$this->redis, $method], $args);
    }
}
```

### 4.4 Service 層範例

#### TrafficService.php - 流量分析服務

```php
<?php
namespace App\Services;

use App\Libraries\Elasticsearch;
use App\Libraries\RedisClient;

class TrafficService {
    private $es;
    private $redis;
    private $cachePrefix = 'traffic:';
    private $cacheTTL = 300; // 5分鐘

    public function __construct() {
        $this->es = Elasticsearch::getInstance();
        $this->redis = RedisClient::getInstance();
    }

    /**
     * 獲取 Top N 流量主機
     */
    public function getTopTalkers($unitId, $timeRange = '1h', $topN = 10) {
        $cacheKey = $this->cachePrefix . "top_talkers:{$unitId}:{$timeRange}:{$topN}";

        return $this->redis->remember($cacheKey, $this->cacheTTL, function() use ($unitId, $timeRange, $topN) {
            $timeFilter = $this->getTimeRangeFilter($timeRange);

            $result = $this->es->aggregateTopN(
                'radar_flow_collector-*',
                'IPV4_SRC_ADDR',
                $topN,
                [
                    ['term' => ['unit_id' => $unitId]],
                    $timeFilter
                ]
            );

            return $this->formatTopTalkersResult($result);
        });
    }

    /**
     * 獲取應用協議分佈
     */
    public function getProtocolDistribution($unitId, $timeRange = '1h') {
        $cacheKey = $this->cachePrefix . "protocols:{$unitId}:{$timeRange}";

        return $this->redis->remember($cacheKey, $this->cacheTTL, function() use ($unitId, $timeRange) {
            $timeFilter = $this->getTimeRangeFilter($timeRange);

            $body = [
                'size' => 0,
                'query' => [
                    'bool' => [
                        'must' => [
                            ['term' => ['unit_id' => $unitId]],
                            $timeFilter
                        ]
                    ]
                ],
                'aggs' => [
                    'protocols' => [
                        'terms' => [
                            'field' => 'L7_PROTO_NAME',
                            'size' => 20
                        ],
                        'aggs' => [
                            'total_bytes' => [
                                'sum' => ['field' => 'TOTAL_BYTES']
                            ]
                        ]
                    ]
                ]
            ];

            $result = $this->es->search('radar_flow_collector-*', $body);
            return $this->formatProtocolResult($result);
        });
    }

    /**
     * 查詢特定 IP 的流量詳情
     */
    public function getIPTraffic($unitId, $ip, $timeRange = '24h', $direction = 'both') {
        $timeFilter = $this->getTimeRangeFilter($timeRange);

        $filters = [
            ['term' => ['unit_id' => $unitId]],
            $timeFilter
        ];

        // 方向過濾
        if ($direction === 'src') {
            $filters[] = ['term' => ['IPV4_SRC_ADDR' => $ip]];
        } elseif ($direction === 'dst') {
            $filters[] = ['term' => ['IPV4_DST_ADDR' => $ip]];
        } else {
            $filters[] = [
                'bool' => [
                    'should' => [
                        ['term' => ['IPV4_SRC_ADDR' => $ip]],
                        ['term' => ['IPV4_DST_ADDR' => $ip]]
                    ]
                ]
            ];
        }

        $body = [
            'query' => ['bool' => ['must' => $filters]],
            'size' => 1000,
            'sort' => [
                'FLOW_START_MILLISECONDS' => ['order' => 'desc']
            ]
        ];

        return $this->es->search('radar_flow_collector-*', $body);
    }

    /**
     * 獲取流量時間序列統計
     */
    public function getTrafficTimeseries($unitId, $timeRange = '24h', $interval = '5m') {
        $timeFilter = $this->getTimeRangeFilter($timeRange);

        $body = [
            'size' => 0,
            'query' => [
                'bool' => [
                    'must' => [
                        ['term' => ['unit_id' => $unitId]],
                        $timeFilter
                    ]
                ]
            ],
            'aggs' => [
                'traffic_over_time' => [
                    'date_histogram' => [
                        'field' => 'FLOW_START_MILLISECONDS',
                        'fixed_interval' => $interval,
                        'min_doc_count' => 0
                    ],
                    'aggs' => [
                        'total_bytes' => ['sum' => ['field' => 'TOTAL_BYTES']],
                        'total_packets' => ['sum' => ['field' => 'TOTAL_PKTS']]
                    ]
                ]
            ]
        ];

        return $this->es->search('radar_flow_collector-*', $body);
    }

    private function getTimeRangeFilter($range) {
        return [
            'range' => [
                'FLOW_START_MILLISECONDS' => [
                    'gte' => "now-{$range}",
                    'lte' => 'now'
                ]
            ]
        ];
    }

    private function formatTopTalkersResult($result) {
        $buckets = $result['aggregations']['top_items']['buckets'] ?? [];

        $formatted = [];
        foreach ($buckets as $bucket) {
            $formatted[] = [
                'ip' => $bucket['key'],
                'total_bytes' => $bucket['total_bytes']['value'],
                'total_packets' => $bucket['total_packets']['value'],
                'count' => $bucket['doc_count']
            ];
        }

        return $formatted;
    }

    private function formatProtocolResult($result) {
        $buckets = $result['aggregations']['protocols']['buckets'] ?? [];

        $formatted = [];
        $total = 0;

        foreach ($buckets as $bucket) {
            $bytes = $bucket['total_bytes']['value'];
            $total += $bytes;

            $formatted[] = [
                'protocol' => $bucket['key'],
                'bytes' => $bytes,
                'count' => $bucket['doc_count']
            ];
        }

        // 計算百分比
        foreach ($formatted as &$item) {
            $item['percentage'] = $total > 0 ? ($item['bytes'] / $total) * 100 : 0;
        }

        return $formatted;
    }

    /**
     * 清除快取
     */
    public function clearCache($unitId = null) {
        if ($unitId) {
            $pattern = $this->cachePrefix . "*:{$unitId}:*";
        } else {
            $pattern = $this->cachePrefix . "*";
        }

        $keys = $this->redis->keys($pattern);
        foreach ($keys as $key) {
            $this->redis->delete($key);
        }
    }
}
```

### 4.5 Controller 層範例

#### TrafficController.php

```php
<?php
namespace App\Controllers;

use App\Services\TrafficService;
use App\Middleware\AuthMiddleware;

class TrafficController extends BaseController {
    private $trafficService;

    public function __construct() {
        parent::__construct();

        // 認證檢查
        AuthMiddleware::check();

        $this->trafficService = new TrafficService();
    }

    /**
     * 流量分析主頁
     */
    public function index() {
        $unitId = $this->getUnitId();

        $data = [
            'title' => '流量分析',
            'unit_id' => $unitId
        ];

        $this->view('traffic/index', $data);
    }

    /**
     * API: 獲取 Top N 流量主機
     */
    public function apiTopTalkers() {
        $unitId = $this->getUnitId();
        $timeRange = $_GET['time_range'] ?? '1h';
        $topN = intval($_GET['top'] ?? 10);

        try {
            $result = $this->trafficService->getTopTalkers($unitId, $timeRange, $topN);

            $this->jsonResponse([
                'success' => true,
                'data' => $result
            ]);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'success' => false,
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * API: 獲取協議分佈
     */
    public function apiProtocols() {
        $unitId = $this->getUnitId();
        $timeRange = $_GET['time_range'] ?? '1h';

        try {
            $result = $this->trafficService->getProtocolDistribution($unitId, $timeRange);

            $this->jsonResponse([
                'success' => true,
                'data' => $result
            ]);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'success' => false,
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * API: 查詢 IP 流量
     */
    public function apiIPTraffic() {
        $unitId = $this->getUnitId();
        $ip = $_GET['ip'] ?? null;
        $timeRange = $_GET['time_range'] ?? '24h';
        $direction = $_GET['direction'] ?? 'both';

        if (!$ip) {
            $this->jsonResponse([
                'success' => false,
                'error' => 'IP parameter is required'
            ], 400);
            return;
        }

        // 驗證 IP 格式
        if (!filter_var($ip, FILTER_VALIDATE_IP)) {
            $this->jsonResponse([
                'success' => false,
                'error' => 'Invalid IP address'
            ], 400);
            return;
        }

        try {
            $result = $this->trafficService->getIPTraffic($unitId, $ip, $timeRange, $direction);

            $this->jsonResponse([
                'success' => true,
                'data' => $result['hits']['hits'] ?? [],
                'total' => $result['hits']['total']['value'] ?? 0
            ]);
        } catch (\Exception $e) {
            $this->jsonResponse([
                'success' => false,
                'error' => $e->getMessage()
            ], 500);
        }
    }

    private function getUnitId() {
        // 從 Session 獲取用戶的 UnitID
        return $_SESSION['user']['unit_id'] ?? 2;
    }
}
```

### 4.6 背景任務 (Cron Jobs)

#### cron/generate_statistics.php - 生成統計數據

```php
<?php
require_once __DIR__ . '/../vendor/autoload.php';

use App\Libraries\Elasticsearch;
use App\Libraries\Database;
use App\Libraries\RedisClient;

/**
 * 定時任務: 生成每日統計數據
 * 執行頻率: 每天 00:05
 */

$es = Elasticsearch::getInstance();
$db = Database::getInstance();
$redis = RedisClient::getInstance();

$yesterday = date('Y.m.d', strtotime('-1 day'));

echo "[" . date('Y-m-d H:i:s') . "] Starting statistics generation for {$yesterday}\n";

// 1. 生成設備可用性統計
generateDeviceAvailability($es, $yesterday);

// 2. 生成單位統計資訊
generateUnitStatistics($es, $db, $yesterday);

// 3. 清除相關快取
clearStatisticsCache($redis);

echo "[" . date('Y-m-d H:i:s') . "] Statistics generation completed\n";

function generateDeviceAvailability($es, $date) {
    echo "Generating device availability for {$date}...\n";

    // 查詢所有設備的狀態記錄
    $body = [
        'size' => 0,
        'aggs' => [
            'per_device' => [
                'terms' => [
                    'field' => 'target',
                    'size' => 10000
                ],
                'aggs' => [
                    'unit_id' => [
                        'terms' => ['field' => 'unit_id', 'size' => 1]
                    ],
                    'total_checks' => [
                        'value_count' => ['field' => 'timestamp']
                    ]
                ]
            ]
        ]
    ];

    $result = $es->search("status-{$date}", $body);

    $bulkBody = [];
    foreach ($result['aggregations']['per_device']['buckets'] as $bucket) {
        $deviceIP = $bucket['key'];
        $unitId = $bucket['unit_id']['buckets'][0]['key'] ?? null;
        $totalChecks = $bucket['total_checks']['value'];

        // 計算可用率 (簡化版，實際應檢查 CPU/Memory 閾值)
        $availability = [
            'ip' => $deviceIP,
            'unit_id' => $unitId,
            'machineType' => 'SW',
            'date' => str_replace('.', '-', $date),
            'dayofweek' => date('w', strtotime($date)),
            'good' => $totalChecks,
            'all' => $totalChecks,
            'rate' => 1.0
        ];

        $bulkBody[] = ['index' => ['_index' => 'device_availability-' . date('Y.m', strtotime($date))]];
        $bulkBody[] = $availability;
    }

    if (!empty($bulkBody)) {
        $es->bulk($bulkBody);
        echo "Indexed " . (count($bulkBody) / 2) . " device availability records\n";
    }
}

function generateUnitStatistics($es, $db, $date) {
    echo "Generating unit statistics for {$date}...\n";

    // 獲取所有單位
    $units = $db->fetchAll("SELECT UnitID FROM Unit");

    foreach ($units as $unit) {
        $unitId = $unit['UnitID'];

        // 統計該單位的流量、設備數等
        $stats = [
            'unit_id' => $unitId,
            'date' => str_replace('.', '-', $date),
            'total_flows' => countFlows($es, $unitId, $date),
            'total_bytes' => sumBytes($es, $unitId, $date),
            'unique_ips' => countUniqueIPs($es, $unitId, $date),
            'device_count' => countDevices($db, $unitId)
        ];

        // 寫入 ES
        $es->index([
            'index' => 'statistics_unit_info_1d-' . date('Y.m', strtotime($date)),
            'body' => $stats
        ]);
    }

    echo "Unit statistics generated\n";
}

function clearStatisticsCache($redis) {
    echo "Clearing statistics cache...\n";

    $patterns = [
        'traffic:*',
        'device:stats:*',
        'dashboard:*'
    ];

    foreach ($patterns as $pattern) {
        $keys = $redis->keys($pattern);
        foreach ($keys as $key) {
            $redis->delete($key);
        }
    }

    echo "Cache cleared\n";
}

function countFlows($es, $unitId, $date) {
    $result = $es->search("radar_flow_collector-{$date}", [
        'size' => 0,
        'query' => ['term' => ['unit_id' => $unitId]]
    ]);

    return $result['hits']['total']['value'] ?? 0;
}

function sumBytes($es, $unitId, $date) {
    $result = $es->search("radar_flow_collector-{$date}", [
        'size' => 0,
        'query' => ['term' => ['unit_id' => $unitId]],
        'aggs' => [
            'total' => ['sum' => ['field' => 'TOTAL_BYTES']]
        ]
    ]);

    return $result['aggregations']['total']['value'] ?? 0;
}

function countUniqueIPs($es, $unitId, $date) {
    $result = $es->search("ip_mapping-{$date}", [
        'size' => 0,
        'query' => ['term' => ['unit_id' => $unitId]],
        'aggs' => [
            'unique_ips' => ['cardinality' => ['field' => 'ip']]
        ]
    ]);

    return $result['aggregations']['unique_ips']['value'] ?? 0;
}

function countDevices($db, $unitId) {
    $result = $db->fetchOne(
        "SELECT COUNT(*) as count FROM Device WHERE UnitID = ? AND status = 1",
        [$unitId]
    );

    return $result['count'] ?? 0;
}
```

#### cron/cache_warmup.php - 快取預熱

```php
<?php
require_once __DIR__ . '/../vendor/autoload.php';

use App\Services\TrafficService;
use App\Services\DeviceService;
use App\Libraries\Database;

/**
 * 定時任務: 快取預熱
 * 執行頻率: 每 5 分鐘
 */

echo "[" . date('Y-m-d H:i:s') . "] Starting cache warmup\n";

$db = Database::getInstance();
$trafficService = new TrafficService();
$deviceService = new DeviceService();

// 獲取所有單位
$units = $db->fetchAll("SELECT UnitID FROM Unit WHERE Unit_Type = 1");

foreach ($units as $unit) {
    $unitId = $unit['UnitID'];

    echo "Warming up cache for Unit {$unitId}...\n";

    try {
        // 預熱流量統計
        $trafficService->getTopTalkers($unitId, '1h', 10);
        $trafficService->getProtocolDistribution($unitId, '1h');

        // 預熱設備狀態
        $deviceService->getOnlineDevices($unitId);
        $deviceService->getDeviceHealth($unitId);

        echo "  ✓ Unit {$unitId} cache warmed\n";
    } catch (\Exception $e) {
        echo "  ✗ Unit {$unitId} failed: " . $e->getMessage() . "\n";
    }

    // 避免過快請求
    usleep(500000); // 0.5 秒
}

echo "[" . date('Y-m-d H:i:s') . "] Cache warmup completed\n";
```

---

## Redis 快取架構

### 5.1 Redis 角色定位

Redis 在 GSNM 系統中扮演**高速快取層**的角色，主要用於:

1. **查詢結果快取** - 減少 ES/MySQL 查詢壓力
2. **Session 存儲** - 用戶登入狀態管理
3. **熱點數據快取** - 儀表板數據、統計結果
4. **API 限流** - Rate Limiting
5. **任務隊列** - 異步任務處理
6. **實時計數器** - 在線用戶數、告警計數等

### 5.2 快取策略設計

#### 5.2.1 快取鍵命名規範

```
格式: {prefix}:{resource}:{identifier}:{param}

範例:
traffic:top_talkers:2:1h:10        # 單位2的1小時Top10流量
device:status:2:192.168.0.10       # 單位2的設備192.168.0.10狀態
user:session:abc123def456          # 用戶Session
dashboard:stats:2                  # 單位2的儀表板統計
api:ratelimit:192.168.0.100:60     # IP限流計數器(60秒窗口)
```

#### 5.2.2 快取分類與 TTL

| 數據類型 | 快取鍵前綴 | TTL | 更新策略 |
|---------|-----------|-----|----------|
| **流量統計** | `traffic:*` | 5分鐘 | 定時更新 + 按需查詢 |
| **設備狀態** | `device:status:*` | 3分鐘 | 定時更新 |
| **設備清單** | `device:list:*` | 10分鐘 | Write-Through (寫入時更新) |
| **用戶 Session** | `user:session:*` | 30分鐘 | 活動時延長 |
| **儀表板數據** | `dashboard:*` | 1分鐘 | 定時更新 |
| **威脅情報** | `threat:*` | 1小時 | 定時同步 MySQL |
| **API 限流** | `api:ratelimit:*` | 依窗口 (60秒/1小時) | 計數器自動過期 |
| **統計報表** | `report:*` | 24小時 | Lazy Loading |

### 5.3 快取使用模式

#### 5.3.1 Cache-Aside Pattern (最常用)

```php
/**
 * 範例: 獲取設備清單
 */
public function getDeviceList($unitId) {
    $cacheKey = "device:list:{$unitId}";

    // 1. 先查 Redis
    $devices = $this->redis->get($cacheKey);

    if ($devices === false) {
        // 2. Redis Miss, 查詢資料庫
        $devices = $this->db->fetchAll(
            "SELECT * FROM Device WHERE UnitID = ? AND status = 1",
            [$unitId]
        );

        // 3. 寫入 Redis
        $this->redis->set($cacheKey, $devices, 600); // 10分鐘
    }

    return $devices;
}
```

#### 5.3.2 Write-Through Pattern

```php
/**
 * 範例: 更新設備資訊
 */
public function updateDevice($deviceId, $data) {
    // 1. 更新資料庫
    $this->db->update('Device', $data, 'ID = ?', [$deviceId]);

    // 2. 同步更新快取
    $device = $this->db->fetchOne(
        "SELECT * FROM Device WHERE ID = ?",
        [$deviceId]
    );

    $unitId = $device['UnitID'];

    // 清除相關快取
    $this->redis->delete("device:list:{$unitId}");
    $this->redis->delete("device:detail:{$deviceId}");
    $this->redis->delete("dashboard:stats:{$unitId}");

    return $device;
}
```

#### 5.3.3 Lazy Loading with Cache Stampede Prevention

```php
/**
 * 範例: 防止快取擊穿 (使用分散式鎖)
 */
public function getExpensiveData($unitId) {
    $cacheKey = "expensive:data:{$unitId}";
    $lockKey = "lock:{$cacheKey}";

    // 嘗試從快取獲取
    $data = $this->redis->get($cacheKey);

    if ($data === false) {
        // 嘗試獲取鎖 (NX: 只在不存在時設定, EX: 過期時間)
        $lockAcquired = $this->redis->set($lockKey, 1, ['NX', 'EX' => 10]);

        if ($lockAcquired) {
            try {
                // 獲得鎖，執行昂貴查詢
                $data = $this->performExpensiveQuery($unitId);

                // 寫入快取
                $this->redis->set($cacheKey, $data, 300);

            } finally {
                // 釋放鎖
                $this->redis->delete($lockKey);
            }
        } else {
            // 沒獲得鎖，等待後重試
            usleep(100000); // 等待 100ms
            return $this->getExpensiveData($unitId); // 遞迴重試
        }
    }

    return $data;
}
```

### 5.4 具體應用場景

#### 5.4.1 儀表板數據快取

```php
/**
 * 儀表板統計數據 (高頻訪問)
 */
public function getDashboardStats($unitId) {
    $cacheKey = "dashboard:stats:{$unitId}";

    return $this->redis->remember($cacheKey, 60, function() use ($unitId) {
        // 從 MySQL 獲取在線數據
        $onlineData = $this->db->fetchOne(
            "SELECT * FROM online_data WHERE UnitID = ?",
            [$unitId]
        );

        // 從 ES 獲取最新流量統計
        $trafficStats = $this->getRecentTrafficStats($unitId);

        // 從 MySQL 獲取告警數量
        $alertCount = $this->getUnresolvedAlertCount($unitId);

        return [
            'sw_online' => $onlineData['SW_Online'] ?? 0,
            'sw_offline' => $onlineData['SW_Offline'] ?? 0,
            'ipv4_use' => $onlineData['IPv4_use'] ?? 0,
            'ip_conflict' => $onlineData['IP_conflict'] ?? 0,
            'traffic_stats' => $trafficStats,
            'alert_count' => $alertCount,
            'updated_at' => time()
        ];
    });
}
```

#### 5.4.2 用戶 Session 管理

```php
/**
 * Session 存儲在 Redis (代替 PHP 原生 Session)
 */
class SessionHandler {
    private $redis;
    private $prefix = 'user:session:';
    private $ttl = 1800; // 30 分鐘

    public function __construct() {
        $this->redis = RedisClient::getInstance();
    }

    public function create($userId, $userData) {
        $sessionId = bin2hex(random_bytes(32));
        $sessionKey = $this->prefix . $sessionId;

        $sessionData = array_merge($userData, [
            'user_id' => $userId,
            'created_at' => time(),
            'last_activity' => time()
        ]);

        $this->redis->set($sessionKey, $sessionData, $this->ttl);

        return $sessionId;
    }

    public function get($sessionId) {
        $sessionKey = $this->prefix . $sessionId;
        $data = $this->redis->get($sessionKey);

        if ($data) {
            // 更新最後活動時間
            $data['last_activity'] = time();
            $this->redis->set($sessionKey, $data, $this->ttl);
        }

        return $data;
    }

    public function destroy($sessionId) {
        $sessionKey = $this->prefix . $sessionId;
        return $this->redis->delete($sessionKey);
    }

    public function refresh($sessionId) {
        $sessionKey = $this->prefix . $sessionId;
        return $this->redis->expire($sessionKey, $this->ttl);
    }
}
```

#### 5.4.3 API 限流 (Rate Limiting)

```php
/**
 * 使用 Redis 實作 API 限流
 */
class RateLimiter {
    private $redis;

    public function __construct() {
        $this->redis = RedisClient::getInstance();
    }

    /**
     * 固定窗口限流
     * @param string $identifier 識別碼 (IP/UserID/API Key)
     * @param int $limit 限制次數
     * @param int $window 時間窗口 (秒)
     */
    public function check($identifier, $limit, $window) {
        $key = "api:ratelimit:{$identifier}:{$window}";

        // 獲取當前計數
        $current = $this->redis->get($key);

        if ($current === false) {
            // 首次訪問
            $this->redis->set($key, 1, $window);
            return true;
        }

        if ($current >= $limit) {
            // 超過限制
            return false;
        }

        // 計數器 +1
        $this->redis->incr($key);
        return true;
    }

    /**
     * 滑動窗口限流 (更精確)
     * 使用 Sorted Set 實作
     */
    public function checkSlidingWindow($identifier, $limit, $window) {
        $key = "api:ratelimit:sliding:{$identifier}";
        $now = microtime(true);
        $windowStart = $now - $window;

        // 移除過期記錄
        $this->redis->zRemRangeByScore($key, 0, $windowStart);

        // 獲取當前窗口內的請求數
        $count = $this->redis->zCard($key);

        if ($count >= $limit) {
            return false;
        }

        // 添加當前請求
        $this->redis->zAdd($key, $now, $now);

        // 設定過期時間
        $this->redis->expire($key, $window);

        return true;
    }
}

/**
 * 中介軟體使用範例
 */
class RateLimitMiddleware {
    public static function check() {
        $limiter = new RateLimiter();
        $ip = $_SERVER['REMOTE_ADDR'];

        // 每分鐘最多 60 次請求
        if (!$limiter->check($ip, 60, 60)) {
            http_response_code(429);
            header('Content-Type: application/json');
            echo json_encode([
                'error' => 'Too Many Requests',
                'message' => 'Rate limit exceeded. Please try again later.'
            ]);
            exit;
        }
    }
}
```

#### 5.4.4 威脅情報快取

```php
/**
 * 威脅情報快取 (減少 MySQL 查詢)
 */
public function isThreatIP($ip) {
    $setKey = "threat:ips";

    // 使用 Redis Set 存儲所有威脅 IP
    if (!$this->redis->exists($setKey)) {
        // 從 MySQL 載入
        $threats = $this->db->fetchAll(
            "SELECT value FROM threat_intelligence WHERE value_type = 'ip'"
        );

        foreach ($threats as $threat) {
            $this->redis->sAdd($setKey, $threat['value']);
        }

        // 設定 1 小時過期
        $this->redis->expire($setKey, 3600);
    }

    return $this->redis->sIsMember($setKey, $ip);
}

/**
 * 定時同步威脅情報 (Cron Job)
 */
public function syncThreatIntelligence() {
    $setKey = "threat:ips";

    // 刪除舊快取
    $this->redis->delete($setKey);

    // 重新載入
    $threats = $this->db->fetchAll(
        "SELECT value FROM threat_intelligence WHERE value_type = 'ip'"
    );

    foreach ($threats as $threat) {
        $this->redis->sAdd($setKey, $threat['value']);
    }

    $this->redis->expire($setKey, 3600);

    echo "Synced " . count($threats) . " threat IPs to Redis\n";
}
```

#### 5.4.5 實時計數器

```php
/**
 * 實時統計在線用戶數、告警數等
 */
class RealtimeCounter {
    private $redis;

    public function __construct() {
        $this->redis = RedisClient::getInstance();
    }

    /**
     * 增加計數
     */
    public function increment($key, $amount = 1) {
        return $this->redis->incrBy("counter:{$key}", $amount);
    }

    /**
     * 減少計數
     */
    public function decrement($key, $amount = 1) {
        return $this->redis->decrBy("counter:{$key}", $amount);
    }

    /**
     * 獲取計數
     */
    public function get($key) {
        $value = $this->redis->get("counter:{$key}");
        return $value !== false ? (int)$value : 0;
    }

    /**
     * 重置計數
     */
    public function reset($key) {
        return $this->redis->set("counter:{$key}", 0);
    }

    /**
     * 使用 Hash 存儲多個計數器
     */
    public function incrementHash($hashKey, $field, $amount = 1) {
        return $this->redis->hIncrBy("counter:hash:{$hashKey}", $field, $amount);
    }

    public function getHash($hashKey) {
        return $this->redis->hGetAll("counter:hash:{$hashKey}");
    }
}

// 使用範例
$counter = new RealtimeCounter();

// 新增安全告警
$counter->increment("unit:2:alerts");

// 設備上線
$counter->increment("unit:2:devices:online");

// 獲取單位2的統計
$stats = [
    'alerts' => $counter->get("unit:2:alerts"),
    'online_devices' => $counter->get("unit:2:devices:online")
];
```

#### 5.4.6 異步任務隊列

```php
/**
 * 使用 Redis List 實作簡單任務隊列
 */
class TaskQueue {
    private $redis;
    private $queueKey = 'queue:tasks';

    public function __construct() {
        $this->redis = RedisClient::getInstance();
    }

    /**
     * 添加任務到隊列
     */
    public function push($task) {
        $taskData = [
            'id' => uniqid(),
            'type' => $task['type'],
            'data' => $task['data'],
            'created_at' => time()
        ];

        return $this->redis->rPush($this->queueKey, json_encode($taskData));
    }

    /**
     * 從隊列取出任務 (阻塞)
     */
    public function pop($timeout = 0) {
        $result = $this->redis->blPop($this->queueKey, $timeout);

        if ($result) {
            return json_decode($result[1], true);
        }

        return null;
    }

    /**
     * 獲取隊列長度
     */
    public function size() {
        return $this->redis->lLen($this->queueKey);
    }
}

// 生產者: 添加任務
$queue = new TaskQueue();
$queue->push([
    'type' => 'send_alert_email',
    'data' => [
        'to' => 'admin@example.com',
        'subject' => 'Security Alert',
        'body' => 'Threat detected...'
    ]
]);

// 消費者: 處理任務 (背景 Worker)
while (true) {
    $task = $queue->pop(5); // 5秒超時

    if ($task) {
        echo "Processing task: {$task['type']}\n";

        switch ($task['type']) {
            case 'send_alert_email':
                sendEmail($task['data']);
                break;
            case 'block_ip':
                blockIPOnFirewall($task['data']);
                break;
        }
    }
}
```

### 5.5 快取管理策略

#### 5.5.1 快取預熱 (Cache Warming)

```php
/**
 * 系統啟動或定時執行快取預熱
 */
public function warmupCache() {
    $units = $this->db->fetchAll("SELECT UnitID FROM Unit");

    foreach ($units as $unit) {
        $unitId = $unit['UnitID'];

        // 預熱儀表板數據
        $this->getDashboardStats($unitId);

        // 預熱設備清單
        $this->getDeviceList($unitId);

        // 預熱流量 Top 10
        $this->trafficService->getTopTalkers($unitId, '1h', 10);
    }
}
```

#### 5.5.2 快取失效 (Cache Invalidation)

```php
/**
 * 快取失效策略
 */
public function invalidateCache($pattern) {
    // 使用 SCAN 避免阻塞 (比 KEYS 安全)
    $cursor = null;
    $deletedCount = 0;

    do {
        $result = $this->redis->scan($cursor, $pattern, 100);
        $cursor = $result[0];
        $keys = $result[1];

        foreach ($keys as $key) {
            $this->redis->delete($key);
            $deletedCount++;
        }
    } while ($cursor != 0);

    return $deletedCount;
}

// 使用範例
// 設備更新後，清除相關快取
$this->invalidateCache("device:*:192.168.0.10*");
$this->invalidateCache("dashboard:stats:2");
```

#### 5.5.3 快取監控

```php
/**
 * 快取命中率監控
 */
class CacheMonitor {
    private $redis;

    public function track($cacheKey, $hit) {
        $statsKey = "cache:stats:" . date('Y-m-d');

        $this->redis->hIncrBy($statsKey, 'total', 1);

        if ($hit) {
            $this->redis->hIncrBy($statsKey, 'hits', 1);
        } else {
            $this->redis->hIncrBy($statsKey, 'misses', 1);
        }

        $this->redis->expire($statsKey, 86400 * 7); // 保留 7 天
    }

    public function getStats($date = null) {
        if ($date === null) {
            $date = date('Y-m-d');
        }

        $statsKey = "cache:stats:{$date}";
        $stats = $this->redis->hGetAll($statsKey);

        $total = $stats['total'] ?? 0;
        $hits = $stats['hits'] ?? 0;
        $misses = $stats['misses'] ?? 0;

        return [
            'total' => $total,
            'hits' => $hits,
            'misses' => $misses,
            'hit_rate' => $total > 0 ? ($hits / $total) * 100 : 0
        ];
    }
}
```

### 5.6 Redis 配置建議

#### redis.conf 關鍵配置

```conf
# 最大記憶體限制
maxmemory 2gb

# 記憶體淘汰策略 (推薦 LRU)
maxmemory-policy allkeys-lru

# 持久化 (建議啟用 AOF)
appendonly yes
appendfsync everysec

# 慢查詢日誌
slowlog-log-slower-than 10000  # 10ms
slowlog-max-len 128

# 客戶端連線數
maxclients 10000

# TCP 連線
tcp-backlog 511
timeout 300

# 禁用危險命令 (生產環境)
rename-command FLUSHDB ""
rename-command FLUSHALL ""
rename-command CONFIG "CONFIG_SECRET_NAME"
```

#### PHP Redis 配置

```php
// config/redis.php
return [
    'host' => getenv('REDIS_HOST') ?: '127.0.0.1',
    'port' => getenv('REDIS_PORT') ?: 6379,
    'password' => getenv('REDIS_PASSWORD') ?: null,
    'database' => 0,
    'timeout' => 2.5,
    'read_timeout' => 2.5,

    // 連線池設定 (使用 phpredis extension)
    'persistent' => true,
    'persistent_id' => 'snm_redis',

    // 序列化方式
    'serializer' => 'php', // php, igbinary, json

    // 前綴 (避免鍵衝突)
    'prefix' => 'snm:',
];
```

---

## 數據存儲架構

### 6.1 數據分離原則

#### ElasticSearch 存儲範圍
- ✅ 時序數據 (Time-Series)
- ✅ 大量寫入數據
- ✅ 需要全文檢索的數據
- ✅ 需要複雜聚合的數據
- ✅ 可容忍部分數據丟失

#### MySQL 存儲範圍
- ✅ 關係數據
- ✅ 需要事務保證的數據
- ✅ 配置與元數據
- ✅ 不可丟失的數據

#### Redis 存儲範圍
- ✅ 臨時數據 (TTL)
- ✅ 高頻讀取數據
- ✅ 計數器與統計
- ✅ Session 與狀態
- ✅ 可重建的數據

### 6.2 數據關聯

#### 關鍵關聯字段

**Unit ID (單位識別)**
```
MySQL: Unit.UnitID (int)
ES: unit_id (keyword)
Redis: 作為鍵的一部分

用途: 多租戶隔離
```

**MAC 地址 (設備識別)**
```
格式標準化:
- MySQL: B869F4A05FE7 (大寫無分隔)
- ES: b869f4a05fe7 (小寫無分隔)
- Redis: 統一為小寫

注意: 跨系統查詢需要格式轉換
```

**IP 地址 (網路識別)**
```
MySQL: varchar(45)
ES: ip type
Redis: string
```

### 6.3 數據同步

```
MySQL ──────────┐
                ▼
          應用層邏輯 ──► Redis (快取)
                │
                ▼
         ElasticSearch (時序數據)
```

---

## 數據流向與處理

### 7.1 數據收集流程

```
網路設備 (SNMP/NetFlow/Syslog)
         │
         ▼
    Radar 探測器 (外部專案)
         │
         ├─► ElasticSearch (寫入原始數據)
         │
         └─► MySQL (寫入元數據, 可選)


ElasticSearch 原始數據
         │
         ▼
   定時聚合任務 (PHP Cron)
         │
         ├─► ElasticSearch (寫入統計索引)
         │
         ├─► MySQL (寫入彙總表)
         │
         └─► Redis (快取預熱)
```

### 7.2 用戶查詢流程

```
用戶請求
    │
    ▼
Controller (路由)
    │
    ▼
Service (檢查 Redis)
    │
    ├─► Redis Hit ──────► 返回結果
    │
    └─► Redis Miss
           │
           ▼
       查詢 ES/MySQL
           │
           ├─► 寫入 Redis
           │
           └─► 返回結果
```

### 7.3 安全告警流程

```
威脅檢測 (比對流量與威脅情報)
    │
    ├─► Redis (威脅 IP Set)
    │
    └─► ElasticSearch (流量數據)
           │
           ▼
      發現威脅 IP
           │
           ├─► MySQL (寫入 Security_log)
           │
           ├─► Redis (計數器 +1)
           │
           ├─► 發送告警 (Email/Webhook)
           │
           └─► 自動封鎖 (防火牆 API)
```

---

## 部署架構

### 8.1 容器化部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  mysql:
    image: mariadb:10.6
    container_name: snm-mysql
    environment:
      MYSQL_ROOT_PASSWORD: gentrice
      MYSQL_DATABASE: Control_DB
      MYSQL_USER: control_user
      MYSQL_PASSWORD: gentrice
    ports:
      - "127.0.0.1:3306:3306"
    volumes:
      - /docker/data/snm/mysql:/var/lib/mysql
    networks:
      - snm_network

  redis:
    image: redis:7-alpine
    container_name: snm-redis
    command: redis-server --appendonly yes --maxmemory 2gb --maxmemory-policy allkeys-lru
    ports:
      - "127.0.0.1:6379:6379"
    volumes:
      - /docker/data/snm/redis:/data
    networks:
      - snm_network

  elasticsearch:
    image: elasticsearch:7.17.28
    container_name: snm-elasticsearch
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms8g -Xmx8g"
      - cluster.name=GSNM-ES
    ports:
      - "127.0.0.1:9200:9200"
    volumes:
      - /docker/data/snm/elasticsearch:/usr/share/elasticsearch/data
    networks:
      - snm_network

  web:
    image: php:8.1-apache
    container_name: snm-web
    volumes:
      - /docker/app/snm-admin-web:/var/www/html
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - mysql
      - redis
      - elasticsearch
    networks:
      - snm_network

networks:
  snm_network:
    driver: bridge
```

### 8.2 網路架構

```
Internet
    │
    ▼
┌─────────────┐
│  防火牆      │  開放: 80/443 (Web), 1701 (L2TP)
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────┐
│  內部網路                        │
│                                 │
│  172.26.1.5  ← Web              │
│  172.26.1.6  ← MySQL            │
│  172.26.1.7  ← Redis            │
│  172.26.1.10 ← ElasticSearch    │
└─────────────────────────────────┘
```

---

## API 設計

### 9.1 RESTful API 端點

詳細 API 文檔請參考 [第8章 系統集成與 API](#系統集成與-api)

### 9.2 API 認證

```php
// 使用 JWT Token 或 API Key
Header: Authorization: Bearer {token}
或
Header: X-API-Key: {api_key}
```

---

## 監控與告警

### 10.1 系統健康監控

**監控指標:**
- ElasticSearch: Cluster Health, Disk Usage
- MySQL: Connection Count, Slow Queries
- Redis: Memory Usage, Hit Rate
- PHP: CPU/Memory Usage, Response Time

**監控工具:**
- ElasticSearch: Kibana Monitoring
- MySQL: phpMyAdmin, MySQL Workbench
- Redis: redis-cli INFO, RedisInsight
- PHP: New Relic, Datadog (可選)

---

## 安全架構

### 11.1 認證與授權

- Web 管理介面: Session-based Auth
- API 訪問: JWT Token / API Key
- 終端用戶: Radius AAA

### 11.2 數據加密

- MySQL 連線: SSL/TLS
- ElasticSearch: HTTPS
- Redis: AUTH 密碼保護
- 敏感數據: AES-256 加密

---

## 效能優化

### 12.1 快取優化

- ✅ 使用 Redis 快取熱點數據
- ✅ 合理設定 TTL
- ✅ 快取預熱
- ✅ 防止快取擊穿

### 12.2 查詢優化

- ✅ ElasticSearch: 限制查詢時間範圍，使用 filter
- ✅ MySQL: 建立適當索引，避免全表掃描
- ✅ 分頁查詢，限制返回數量

### 12.3 連線池

- ✅ MySQL: 使用持久連線 (PDO::ATTR_PERSISTENT)
- ✅ Redis: 使用持久連線
- ✅ ElasticSearch: 連線復用

---

## 故障排查指南

### 13.1 Redis 相關問題

**問題: Redis 記憶體滿**
```bash
# 查看記憶體使用
redis-cli INFO memory

# 清理過期鍵
redis-cli --scan --pattern "expired:*" | xargs redis-cli DEL

# 調整淘汰策略
CONFIG SET maxmemory-policy allkeys-lru
```

**問題: Redis 連線過多**
```bash
# 查看客戶端連線
redis-cli CLIENT LIST

# 殺死閒置連線
redis-cli CLIENT KILL TYPE normal SKIPME yes
```

### 13.2 PHP 相關問題

**問題: PHP 記憶體不足**
```php
// php.ini
memory_limit = 512M

// 程式碼中臨時調整
ini_set('memory_limit', '512M');
```

**問題: PHP 執行超時**
```php
// php.ini
max_execution_time = 300

// 程式碼中調整
set_time_limit(300);
```

### 13.3 效能分析

**慢查詢分析:**
```php
// 記錄查詢時間
$start = microtime(true);

$result = $this->db->query($sql);

$duration = microtime(true) - $start;

if ($duration > 0.5) {
    error_log("Slow query ({$duration}s): {$sql}");
}
```

**快取命中率分析:**
```php
// 使用 CacheMonitor 追蹤
$monitor = new CacheMonitor();
$stats = $monitor->getStats();

echo "Cache Hit Rate: {$stats['hit_rate']}%\n";
```

---

## 附錄

### A. 配置文件範例

**config/database.php**
```php
<?php
return [
    'host' => getenv('DB_HOST') ?: '127.0.0.1',
    'port' => getenv('DB_PORT') ?: 3306,
    'database' => getenv('DB_NAME') ?: 'Control_DB',
    'username' => getenv('DB_USER') ?: 'control_user',
    'password' => getenv('DB_PASS') ?: 'gentrice',
    'charset' => 'utf8mb4',
    'collation' => 'utf8mb4_unicode_ci',
];
```

**config/elasticsearch.php**
```php
<?php
return [
    'host' => getenv('ES_HOST') ?: 'http://localhost:9200',
    'max_result_window' => 10000,
    'timeout' => 30,
];
```

**config/redis.php**
```php
<?php
return [
    'host' => getenv('REDIS_HOST') ?: '127.0.0.1',
    'port' => getenv('REDIS_PORT') ?: 6379,
    'password' => getenv('REDIS_PASSWORD') ?: null,
    'database' => 0,
    'timeout' => 2.5,
    'prefix' => 'snm:',
];
```

### B. Crontab 設定

```bash
# 每 5 分鐘執行快取預熱
*/5 * * * * php /var/www/html/cron/cache_warmup.php >> /var/log/cron.log 2>&1

# 每天 00:05 生成統計數據
5 0 * * * php /var/www/html/cron/generate_statistics.php >> /var/log/cron.log 2>&1

# 每小時更新威脅情報
0 * * * * php /var/www/html/cron/update_threat_intel.php >> /var/log/cron.log 2>&1

# 每天 02:00 清理舊數據
0 2 * * * php /var/www/html/cron/cleanup_old_data.php >> /var/log/cron.log 2>&1
```

### C. 相關文件

- **數據結構報告:** `數據結構整理報告.md`
- **ElasticSearch 文檔:** https://www.elastic.co/guide/en/elasticsearch/reference/7.17/
- **MariaDB 文檔:** https://mariadb.com/kb/en/documentation/
- **Redis 文檔:** https://redis.io/documentation
- **PHP Manual:** https://www.php.net/manual/

---

**文件結束**

*本文件將持續更新，如有任何問題或建議，請聯絡系統管理團隊。*
